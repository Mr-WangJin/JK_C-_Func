#ifndef __JK_ARRAY_HPP_INCLUDED__
#define __JK_ARRAY_HPP_INCLUDED__

#include "jk_assert.hpp"

namespace JK {

// Fixed-size array
template <typename T, unsigned N>
class array {
 public:
	typedef unsigned size_type;	
	
	// Most commonly used constructors:
	array() {}
	explicit array(const T& initial_value) {
		for(size_type i=0; i<size(); ++i)
			data_[i] = initial_value;
	}

	size_type size() const { return N; }
	
	// Note: we do not provide a copy-ctor and assignment operator.
	// we rely on default versions of these methods generated by the compiler.
	
	T& operator [] (size_type index) {
		JK_TEST_ASSERT(index < N,
			"Index " << index << " must be less than " << N);
		return data_[index];
	}

	const T& operator [] (size_type index) const {
		JK_TEST_ASSERT(index < N,
			"Index " << index << " must be less than " << N);
		return data_[index];
	}
	
	// Accessors
	T* begin() { return &data_[0]; }
	const T* begin() const { return &data_[0]; }
	
	// Returns pointer PAST the end of the array.
	T* end() { return &data_[N]; }
	const T* end() const { return &data_[N]; }

  private:
	T data_[N];
};
} // namespace jk


template <typename T, unsigned N>
inline
std::ostream& operator << (std::ostream& os, const jk::array<T,N>& a) {
	for( unsigned i=0; i<a.size(); ++i ) {
		os << a[i];
		if( i + 1 < a.size() )
				os << " ";
	}
	return os;
}

#endif // __JK_ARRAY_HPP_INCLUDED__